size_alloc = 1000# {{data_size}}
decimal_accuracy = 0.00001 #{{decimal_accuracy}}
cells = 3 # {{cells}}
mask = sint.Array(size_alloc) #add dynamic memory

def output_random_triples(cond):
  # naming as in Damgard et al
  y, r, w = sint.get_random_triple()
  v, un1, un2 = sint.get_random_triple()
  u = v * r
  outp = [y, r, w, v, u]
  output_shares(2,*outp)
  #outp2 = [v, u]
  #output_shares(2,*outp2)
  mask[cond] = y
  return cond + 1

open_channel(0)
open_channel(1)

n = regint.public_input(1)
print_ln("Dataset size %s", n)

open_channel(2)

while_loop(output_random_triples, lambda x: x<n, 0)

open_channel(3) # construct triples
open_channel(4) # get data

masked_data = sint.Array(size_alloc) #add dynamic memory

def import_data(cond):
  # naming as in Damgard et al
  y = cint.public_input(1000)
  masked_data[cond] = y
  return cond + 1

while_loop(import_data, lambda x: x < n, 0)

intdata = sint.Array(size_alloc)

@for_range(n)
def range_body(i):
  intdata[i] = masked_data[i] + mask[i]

data = sfix.Array(size_alloc/2)
@for_range(n/2)
def range_body(i):
  data[i] = sfix(intdata[2*i] + sfloat(intdata[2*i + 1]) * decimal_accuracy)

#@for_range(n/2)
#def range_body(i):
#  print_ln("%s", (data[i]).reveal() ) 

close_channel(0)
close_channel(1)
close_channel(2)
close_channel(3)
close_channel(4)

# --------------------------------------------------------------------------------------
# ======================================================================================
# --------------------------------------------------------------------------------------

maximum_element_address = program.malloc(1, sfix)
store_in_mem(data[0], maximum_element_address)


@for_range(15)
def range_body(i):
  max = sfix.load_mem(maximum_element_address)
  max = max * (max >= data[i]) + data[i] * (max < data[i])
  store_in_mem(max, maximum_element_address)
  
print_ln("%s", sfix.load_mem(maximum_element_address).reveal())